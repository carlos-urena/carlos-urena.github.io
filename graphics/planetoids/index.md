---
usemathjax: true
---

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

$$
   \newcommand{\cv}{\mathbf{v}}
$$

Written March 22, 2023.

# Procedural generation of planetoids.

On this page, I explain how to use a procedural generation algorithm to create an indexed mesh that resembles a planet or _planetoid_. I start from a (high resolution) unit radius sphere and then I radially displace the vertexes using Perlin Noise. An example mesh (for a particular set of parameter values) is seen here:

<center>
<img src="imgs/img11.png" width="45%"/>
</center>

This generation algorithm has been tested in C++ but can be adapted to other programming languages, running from scratch or on any game engine.

## 1. High-resolution sphere.

The generation algorithm must use a high-resolution sphere, as we want to add high-resolution variations to enhance realism. Generating a high-resolution sphere can be easily done by using the usual parametrization of the sphere, based on longitude and latitude angles (that is, by rotating a semi-circumference going from the south to the north pole). However, this method produces triangles with a high variation in area and proportions, as it yields very small triangles near the poles and quite big ones near the equator. 

To solve this, we use a regular polyhedron (more concretely a platonic solid [[1]](#1)), whose vertexes are in the unit radius sphere, and which includes just equilateral triangles, all of them congruent (same area and edges length). Of all the platonic solids meeting this requirement, I choose the _Regular Icosahedron_ [[2]](#2), because this is the platonic solid with the largest number of triangles (20), and the smaller the original polyhedron triangles, the smaller triangle area variation we get in the final high-resolution mesh.

After the icosahedron is generated, its triangles are iteratively subdivided, until a target resolution is reached. I detail both the icosahedron generation and the subdivision process below.

### 1.1. Icosahedron generation.

Regular icosahedron 12 vertexes can be generated by considering their spherical coordinates as detailed in [[2]](#2). Thus, we can enumerate the vertexes as follows:

* A _south pole_ vertex at coordinates $$(0,-1,0)$$ (index $$0$$ vertex)
* A _north pole_ vertex at coordinates $$(0,1,0)$$ (index $$1$$ vertex)
* Five _lower ring_ vertexes, forming a regular pentagon at latitude $$\beta\,=\,-\arctan(1/2)$$ (indexes $$2$$ to $$6$$). Thus, the $$y$$ coordinate for all these vertexes is $$y\,=\,\sin\beta\,=\,-1/\sqrt{5}$$. The longitude angle is $$2\pi\,i/5$$, with $$i$$ ranging from $$0$$ to $$4$$. The radius of the pentagon is $$-2y$$
* Five _upper ring_ vertexes, forming a regular pentagon at latitude $$+\arctan(1/2)$$ (indexes $$7$$ to $$11$$). The longitude angles are shifted so each upper ring vertex is between two lower ring vertexes. Thus, they can be generated by using longitude angles $$2\pi\,(i+1/2)/5$$, for each $$i$$ from $$0$$ to $$4$$. The $$y$$ coordinate is now $$1/\sqrt{5}$$, and the radius $$2y$$.

The C++ code to generate the vertex table (a `std::vector` of 3-float tuples, named `vertices`) is this:

```cpp 
const float h = 1.0f/sqrt(5.0f),  // y coordinate for south and north rings.
            r = 2.0f*h ;          // radius to Y axis for south and north rings

// south pole and north pole
vertices.push_back({ 0.0f, -1.0f, 0.0f }); // south --> 0
vertices.push_back({ 0.0f, +1.0f, 0.0f }); // north --> 1

// add lower (south) ring of vertexes
for( unsigned i = 0 ; i < 5 ; i++ )
{
   const float a = (float(i)*2.0f*M_PI)/5.0f ;
   vertices.push_back({ r*cosf(a), -h, r*sinf(a) });
}
// add upper (north) ring of vertexes
for( unsigned i = 0 ; i < 5 ; i++ )
{
   const float a = ((float(i)+0.5f)*2.0f*M_PI)/5.0f ;
   vertices.push_back({ r*cosf(a), +h, r*sinf(a) });
}
```

The triangles table (a `std::vector`of 3-unsigned tuples, named `triangles`) can be generated by producing 5 triangles adjacent to the south pole and lower ring vertexes, another 5 triangles adjacent to both rings and finally 5 triangles adjacent to the upper ring and north pole. 

```cpp 
// triangles adjacent to south pole (vertex 0)
for( unsigned i = 0 ; i < 5 ; i++ )
   triangles.push_back({ 0, 2+i, 2+((i+1)%5)  });

// triangles between south and north rings 
for( unsigned i = 0 ; i < 5 ; i++ )
{
   const unsigned 
      n0 = 7+i, n1 = 7+(i+1)%5, 
      s0 = 2+i, s1 = 2+(i+1)%5 ;

   triangulos.push_back({ s0, n0, s1 });
   triangulos.push_back({ n0, n1, s1 });
}

// triangles adjacent to north pole (vertex 1)
for( unsigned i = 0 ; i < 5 ; i++ )
   triangules.push_back({ 1, 7+((i+1)%5), 7+i });
```

### 1.2. Triangles subdivisions.

Once the Icosahedron has been generated, I split each original triangle into 4 triangles, which replace the original one. Thus I obtain an 80 triangles mesh. This process can be repeated $$n$$ times, each time subdividing every triangle in the mesh, so in the end we get an indexed mesh with exactly $$20\cdot 4^n$$ triangles. 

To subdivide a triangle into four, three new vertexes are added to the mesh vertex table, each one is placed in the middle of each edge of the original triangle. The three original vertexes, along with the three new ones, are used as vertexes for the new 4 triangles, which are also equilateral. These new triangles are added to the triangles table, while the original triangle is removed from that table.

This process leads to a mesh with the shape of an Icosahedron, made of small triangles, all of them with equal area. Each triangle is on one of the original Icosahdreon faces planes. As we want to obtain a sphere, we must modify the position of the new vertexes during the subdivision step: when a new vertex is computed (in the middle point of an edge), it is normalized before adding it to the vertexes table, that is, we displace the new vertex radially so it meets the unit-radius sphere surface. This normalization implies that the new four triangles are not the same area, but the area differences are very small as compared to the area difference you obtain with the latitude-longitude sphere generation algorithm. This can be verified visually, as you can assess by observing the final high-resolution sphere mesh.


## 2. Vertex displacement.

After computing the sphere, we need to modify the vertexes' positions to give it a characteristical _bumpy_ look. The natural option for this is to apply a radial displacement to each vertex, that is, to use a scalar factor $$f_i$$ to modify the distance from the origin to the $$i$$-th vertex. This yields a mesh resembling a planet whose height is different at each point, where _height_ here means the _distance__ to the_ planet's center_. If we name $$\cv_i$$ to the original position of the vertex and $$\cv_i'$$ the displaced position, we will compute the latter from the former as:

$$
     \cv_i' ~=~ f_i\, \cv_i
$$ 

Here, we assume we are using a cartesian coordinate frame whose origin is in the planet-center

## References.

<a id="1">[1]</a> 
_Platonic Solid_ in _Wikipedia: The Free Encyclopedia_, available from [https://en.wikipedia.org/wiki/Platonic_solid](https://en.wikipedia.org/wiki/Platonic_solid), retrieved March 22, 2023.

<a id="2">[2]</a> 
_Regular Icosahedron_ in _Wikipedia: The Free Encyclopedia_, available from [https://en.wikipedia.org/wiki/Regular_icosahedron](https://en.wikipedia.org/wiki/Regular_icosahedron), retrieved March 22, 2023.